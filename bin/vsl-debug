#! /usr/bin/python3
# coding: utf-8
#
# Very Simple Launcher
#
# Copyright (C) Ita√Ø BEN YAACOV
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


import sys
import gc
import types
import traceback
import signal


from vsl import app


signal._int_to_enum = lambda value, enum_klass: enum_klass(value) if isinstance(value, int) else value
gc.disable()


app.App().run(sys.argv)



def shortstr(obj, l=1000):
    if isinstance(obj, types.FrameType):
        TEXT = "{} {} {}".format(obj, obj.f_code.co_filename, obj.f_lineno)
    elif isinstance(obj, Exception):
        TEXT = "{} {}".format(obj, id(obj))
    else:
        TEXT = str(obj) + ' ' + str(id(obj))
    return TEXT if len(TEXT) < l else TEXT[:l] + "..."


class NaiveReferenceTree(object):
    def __init__(self, top):
        self.top = top
        self._referred = []

    def nodes(self):
        for node in self._referred:
            yield from node.nodes()
        yield self

    def paths(self):
        for node in self._referred:
            for path in node.paths():
                yield [self] + path
        yield [self]

    def add_node(self, node):
        for p in node.paths():
            if self == p[-1]:
                l = len(p)
                print('LOOP of length {}'.format(l))
                for n in p:
                    print('--', type(n.top), shortstr(n.top))
                    if type(n.top).__name__ == 'traceback':
                        for line in traceback.format_tb(n.top):
                            print(line)
                return
        if node not in self._referred:
            self._referred.append(node)

    def print(self, lvl=0):
        if self.top is not None:
            print('{} [{}] {}'.format('-' * lvl, type(self.top).__name__, shortstr(self.top)))
            if type(self.top).__name__ == 'traceback':
                traceback.print_tb(self.top)
        for n in self._referred:
            n.print(lvl + 1)


class NaiveReferenceTreeTop(NaiveReferenceTree):
    def __init__(self):
        NaiveReferenceTree.__init__(self, None)

    def new_object(self, obj):
        node = NaiveReferenceTree(obj)
        self.add_node(node)
        return node

    def improve(self):
        for o in list(self._referred):
            if isinstance(o.top, dict) and '__loader__' in o.top:
                self._referred.remove(o)
        for o in list(self._referred):
            found = False
            for r in gc.get_referrers(o.top):
                if isinstance(r, NaiveReferenceTree) or (type(r) == dict and 'top' in r):
                    continue
                for node in self.nodes():
                    if r is node.top:
                        break
                else:
                    node = self.new_object(r)
                node.add_node(o)
                found = True
            if found:
                self._referred.remove(o)

    def add_objects(self, test, show=False):
        for o in gc.get_objects():
            if test(o):
                self.new_object(o)
                if show:
                    for x in gc.get_referrers(o):
                        print(x)


T = NaiveReferenceTreeTop()


def test(o):
    for prefix in ('vsl', 'gasyncio'):
        if type(o).__module__.startswith(prefix):
            return True
    return False


# T.add_objects(lambda o: 'Window' == o.__class__.__name__)
T.add_objects(test)


T.improve()
T.improve()
T.improve()
T.improve()
T.improve()
# T.improve()
# T.improve()
# T.improve()
# T.improve()
T.print()

del T
